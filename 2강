## **도형 그리기**

- **`트라이앵글(Triangle)`**: 3개의 점을 연결하여 삼각형을 그리는 함수임. 매개변수로는 각 점의 x, y 좌표가 필요함.
- **`쿼드(Quad)`**: 4개의 점을 연결하여 사각형을 그리는 함수임. **`라인(Line)`** 함수와 유사하지만 점이 4개임.

## **도형 그리기 명령어 비교**

1. **엘립스(Ellipse) vs 써클(Circle)**
    - **`엘립스`**: 타원을 그리는 명령어임. 매개변수로는 중심점의 x 좌표, y 좌표, 너비, 높이를 입력함.
    - **`써클`**: 원을 그리는 명령어로, 중심점의 x 좌표, y 좌표, 그리고 반지름을 입력함.
2. **스퀘어(Square) vs 렉트(Rect)**
    - **`스퀘어`**: 정사각형을 그리는 명령어로, 중심점의 x 좌표, y 좌표, 그리고 한 변의 길이를 입력함.
    - **`렉트`**: 사각형을 그리는 명령어로, x 좌표, y 좌표, 너비, 높이를 입력함. 기본적으로는 x 좌표와 y 좌표를 중심으로 하고, 너비와 높이로 크기를 조절함. 그러나 다른 상황에서는 다른 매개변수를 사용할 수 있음.

---

## **렉트 모드(Rect Mode)와 엘립스 모드(Ellipse Mode)**

- **렉트 모드**는 사각형을 그리는 명령어임. 매개변수로는 코너(Corner), 코너스(Corners), 레이어스(Radius), 센터(Center)가 있음.
    - **코너(Corner)**: 기본 설정값으로, 사각형의 좌측 상단 코너에 점의 위치를 나타냄.
    - **코너스(Corners)**: 사각형의 우측 하단 코너에 점의 위치를 나타냄.
    - **레이어스(Radius)**: 중심점으로부터 각 모서리까지의 거리를 나타냄.
    - **센터(Center)**: 중심점을 나타냄. 너비와 높이는 중심점을 중심으로 함.
- **엘립스 모드**는 타원을 그리는 명령어임. 매개변수로는 코너(Corner), 코너스(Corners), 레이어스(Radius), 센터(Center)가 있음.
    - **코너(Corner)**: 기본 설정값으로, 타원의 좌측 상단 코너에 점의 위치를 나타냄
    - **코너스(Corners)**: 타원의 우측 하단 코너에 점의 위치를 나타냄.
    - **레이어스(Radius)**: 중심점으로부터 타원의 모서리까지의 거리를 나타냄.
    - **센터(Center)**: 중심점을 나타냅니다. 반지름은 중심점을 중심으로 함.

**스트로크(Stroke)와 스트로크 두께**

- **스트로크**는 선을 그리는 두께를 조절하는 명령어임. 매개변수로는 선의 두께를 나타내는 숫자를 입력함. 기본 설정값은 1임.
- 두께를 바꾸면 선의 두께가 변경되어, 더 두꺼운 선이나 더 얇은 선을 그릴 수 있음.

---

## **비긴 쉐이프 앤드 쉘(Begin Shape, End Shape)**

- **비긴 쉐이프(Begin Shape)** 명령어는 그림을 그리기 시작할 때 사용함.
- **엔드 쉐이프(End Shape)** 명령어는 그림 그리기를 종료할 때 사용함.

그러면, 심벌의 아랫부분을 그리기 위해선 먼저 **`BEGIN_SHAPE()`**로 그림 그리기를 시작하고, **`END_SHAPE()`**로 그림 그리기를 종료해야 함.

이제, **`VERTEX()`** 명령어를 사용하여 점들을 연결하여 선을 그릴 수 있음. **`VERTEX()`** 명령어는 점의 좌표를 설정하는 명령어로, 여러 개의 점을 이어 선을 그릴 수 있음. 이 점들은 **`BEGIN_SHAPE()`**와 **`END_SHAPE()`** 사이에 위치해야 함.

예를 들어, **`VERTEX(10, 40)`**과 같이 입력하면 (10, 40) 위치에 점이 그려지며, 이렇게 설정한 점들이 **`END_SHAPE()`** 명령어가 호출될 때까지 선으로 연결됨.

다음으로는 **`BEGIN_SHAPE()`**로 그림 그리기를 시작하고, **`END_SHAPE()`**로 그림 그리기를 종료한 후에, 원하시는 점들을 **`VERTEX()`** 명령어를 이용하여 입력하면 됨.

---

## **도형 및 색상 설정을 설명하는 로고 디자인 과정**

1. 끝 쉐입' 명령어를 사용하여 다각형을 그릴 수 있음.
2. '비긴 쉐입' 명령어를 사용하기 전에 '노우'를 넣으면 색이 자동으로 칠해지지 않음
3. 눈을 그릴 때는 손에 두께를 이용하여 점을 찍음. 스트로크 에이트를 조절하여 눈을 그림
4. '백그라운드' 명령어를 사용하여 배경색을 깨끗하게 지울 수 있음. 이 명령어는 반투명하게 지우지 않음.
5. 색상 선택 방법은 HSB를 사용할 수 있음. H 값은 색상을, S 값은 채도를, B 값은 밝기를 나타냄
6. HSB에서 왼쪽은 0, 오른쪽은 99까지의 범위를 가지며, 위로 갈수록 값을 증가시킴

---

## 색상 선택과 코딩 프로세싱에 관한 설명

1. HSB 색상 선택 방법은 색상, 채도, 명도를 조절하여 색상을 선택함.
2. '컬러 모드' 명령어를 사용하여 RGB 또는 HSB 중 하나를 선택하여 색상을 선택함
3. RGB로 빨간색을 선택한 경우, HSB로 변환하면 채도와 명도를 조절하여 다른 색상을 선택할 수 있음.
4. 색상 선택 창에서 H 값은 360도, 채도와 명도는 0에서 99 사이의 값을 가짐.
5. 코드를 사용하여 도형을 그릴 때는 '마우스 x'와 '마우스 y'를 사용하여 마우스의 위치에 따라 도형을 그릴 수 있음.

---

## **인터랙티브 소프트웨어 개발 과정**

1. 프로그램은 마우스의 움직임에 따라 원을 그리는 인터랙티브 소프트웨어임
2. '높이' 명령어를 사용하여 외곽선을 지우고, '은' 명령어를 사용하여 원을 반투명하게 그림
3. 화면을 반투명한 검정색으로 지우고, 흰색으로 반투명하게 원을 그린 후, 반투명하게 다시 지우는 과정을 반복하여 잔상을 만듬.
4. 프로그램을 수정하고 가독성을 높이기 위해 들여쓰기를 사용함.
5. 원이 회색으로 보이는 이유는 반투명하게 지워진 영역 때문이므로, 투명도를 없애서 완전한 흰색으로 바꿔줌.

---

## 프로세싱으로 실시간 그림 그리기: 마우스 인터랙션을 통한 선 연결 프로그램

- 기존 코드를 분석한 결과, 현재의 프로그램은 다음과 같은 순서로 동작함.
    1. 흰색으로 그리고, 지우면서, 그리고, 60초 대기.
    2. 흰색으로 그리고, 치우고, 다시 60초 대기.
    3. 이 과정을 반복.
- 원하는 동작은 다음과 같음
    - 먼저, 이전에 그려진 그림을 반투명하게 지운 후 흰색으로 그림
    - 그리고, 마우스의 이동에 따라 선이 쭉 연결되는 프로그램을 만들고자 함.
- 이를 위해 코드를 수정하고 실행하면, 원하는 동작이 완성됨. 코드는 매우 간단하며, 실행되는 로직은 다음과 같음.
    1. 윈도우를 생성하고, 흰색으로 지우고 그림을 그리며, 60프레임/초로 동작함.
    2. 마우스의 위치를 기반으로 이전 위치부터 현재 위치까지 선을 연결하여 그림.
- 현재는 원을 그리는데, 마우스 이동이 빠르면 선이 끊기는 현상이 발생함.
- 이를 보완하기 위해, 마우스 이동에 따라 선이 연결되도록 수정해야 함.
- 프로세싱으로 이 프로그램을 만들 때 주의할 점은 다음과 같음.
    - 코드의 간결성과 가독성 유지.
    - 프레임 레이트에 따라 마우스 이동에 따라 그려지는 선의 부드러움이 달라질 수 있음.

---

## 프로세싱 코드 수정 및 설명 1

- 이전에는 원을 그리는 대신 라인을 사용하여 마우스의 이동에 따라 선을 그리도록 코드를 수정했음.
- p마우스.x 및 p마우스.y를 사용하여 이전 마우스 위치를 기억함.
- 라인 명령어를 사용하여 흰색 선을 그리고, 스트로크와 레프트 트로를 설정하여 선의 두께와 모양을 조절함.
- 마지막으로, 마우스 클릭 및 키보드 입력에 반응하는 함수를 추가하기 위해 마우스 프레스드 및 키 프레스드 함수를 사용함.

---

## 프로세싱 코드 수정 및 설명 2

- 먼저 500x500 픽셀 크기의 창을 생성하고, 마우스 클릭시 원이 그려지도록 코드를 작성함.
- 엘립스 대신 라인 명령어를 사용하여 마우스의 이동에 따라 선을 그리도록 코드를 수정함
- 마우스 클릭 시 '마우스 프레스드' 함수를 사용하여 클릭한 순간에 코드가 실행되도록 하였고, 키보드 입력 시 '키 프레스드' 함수를 사용하여 화면을 검정색으로 지우도록 코드를 작성했음.
- 마우스 및 키보드 관련 함수들을 사용하여 프로그램이 마우스와 키보드 입력에 반응하도록 추가했음.
- 마우스와 키보드 관련 함수들은 '마우스 프레스드', '마우스 릴리즈드', '마우스 타입드', '키 프레스드', '키 릴리즈드', '키 타입드' 등이 있으며, 각각 해당 이벤트가 발생할 때 실행됨.
- 이러한 함수들을 활용하여 마우스와 키보드 입력에 따른 동작을 정의할 수 있음.  이를 통해 프로그램의 기능을 확장시킬 수 있음.

---

## 프로세싱 코드 수정 및 설명

- HSB 대신 RGB 색상 모드를 사용하여 코드를 작성함,
- 백그라운드를 지우는 부분을 setup 함수 내에 위치시켜 한 번만 실행되도록 했음.
- 초록색을 고정하고, 다른 색상은 필요에 따라 변경될 수 있도록 코드를 작성했음.
- 스트로크의 두께를 조절하여 선의 굵기를 다르게 하였고, 로본 부분은 변하지 않도록 고정시켰음.
- 텍스트를 회전시켜 세로로 표시되도록 하였고, 한 번만 실행되어야 하는 명령어는 setup 함수에 위치시켜 코드를 정리했음.

---

## **프로세싱을 활용한 마우스 위치에 따라 런버블 로고 그리기**

1. **코드 개요**
    - 이 코드는 마우스 위치에 따라 런버블 로고를 그리고 이동시키는 역할을 함.
2. **주요 기능**
    - 검은색 배경을 설정하고, 선의 두께를 3으로 지정함.
    - 런버블 로고는 눈과 입으로 구성되어 있음.
    - 입 부분은 마우스 위치를 기준으로 수평선을 그리고, 눈 부분은 수직선을 그림.
    - ellipse() 함수를 사용하여 런버블 로고 자체를 그림.
3. **주석 설명**
    - 코드에는 주석을 통해 각 부분의 역할과 동작 방식이 설명되어 있음.
    - 주석을 통해 코드를 이해하는 데 도움이 됨
4. **코드 재사용성**
    - 주석을 통해 코드를 읽는 사람이 코드를 쉽게 이해할 수 있도록 설명되어 있음.
    - 이를 통해 코드를 수정하거나 재사용할 때 유용함.

```c
// 이 코드는 러버블랙 로고를 그리고, 지우고 선 두께를 정하며, 러버블 로고를 입부분과 눈을 그리는 것을 포함합니다.

// 백그라운드 색상을 설정합니다.
background(0);

// 라인의 두께를 설정합니다.
strokeWeight(3);

// 로고를 그립니다.
// 입 부분
line(mouseX - 50, mouseY + 50, mouseX + 50, mouseY + 50);
// 눈 부분
line(mouseX - 20, mouseY - 30, mouseX - 20, mouseY + 30);
line(mouseX + 20, mouseY - 30, mouseX + 20, mouseY + 30);

// 손 두껍게 설정
strokeWeight(10);
// 러버블 로고를 그립니다.
ellipse(mouseX, mouseY, 100, 100);

// 마우스 위치에 따라 러버블 로고가 이동하도록 설정합니다.
// 입 부분
line(mouseX - 50, mouseY + 50, mouseX + 50, mouseY + 50);
// 눈 부분
line(mouseX - 20, mouseY - 30, mouseX - 20, mouseY + 30);
line(mouseX + 20, mouseY - 30, mouseX + 20, mouseY + 30);

// 주석을 추가하여 코드를 설명합니다.
// '/'로 시작해서 '/'로 끝나는 주석은 프로세싱에서 무시됩니다.
// 이렇게 설명을 추가하면 코드를 이해하기 쉬워집니다.

```

---

## **마우스 위치에 따라 동적으로 점 이동시키기**

1. **코드 개요**
    - 이 코드는 마우스 위치에 따라 다양한 위치에 점을 그리고 이동시키는 역할을 함.
    
2. **주요 기능**
    - 점들은 마우스 위치를 기준으로 상대적인 위치에 따라 이동함.
    - 각 점은 마우스의 위치와 일정한 거리만큼 떨어진 위치에 그려짐.
    - 마우스의 위치와 상대적인 거리는 코드를 통해 계산됨
3. **코드 설명**
    - 코드 내에는 마우스의 위치를 기준으로 점들의 상대적인 위치를 계산하는 과정이 주석으로 설명되어 있음.
    - 마우스 위치와의 상대적인 거리를 계산하기 위해 각 점의 초기 위치에서 일정한 값을 더하거나 빼는 방식이 사용됨
4. **동작 확인**
    - 코드를 실행하면 마우스를 움직일 때마다 점들이 마우스의 위치를 기준으로 이동함.
    - 마우스를 움직이는 동안 각 점의 위치가 동적으로 변화하는 것을 확인할 수 있음.

---

## 코드 상으로 더하고 빼고 곱하고 나누는 방법 설명

프로그램 코드에서는 사칙연산을 활용하여 마우스 위치에 따라 원하는 위치를 계산할 수 있음. 이를 통해 그림이 상대적으로 이동하도록 만들 수 있음. 

예를 들어, 마우스의 x 좌표에서 40을 더하고 y 좌표에서 40을 빼면 마우스 위치를 기준으로 점을 그릴 수 있음. 마찬가지로, 다른 요소들도 마우스를 따라다니도록 설정할 수 있음.

연산 순서를 지켜야 함. 곱하기와 나누기가 먼저 실행되고, 그 다음에 더하기와 빼기가 실행됨. 

괄호를 사용하여 연산 순서를 조절할 수도 있음. 괄호를 사용할 때는 시작하는 괄호와 대응하는 닫히는 괄호를 반드시 쌍으로 사용해야 함. 이렇게 함으로써 코드를 명확하게 작성하고, 프로그램에서 발생할 수 있는 오류를 방지할 수 있음.

---

## 4층 연산을 이용한 애니메이션 만들기

1. 4층 연산에 대한 학습 후 애니메이션 제작을 시작함
2. 배경을 검정색으로 설정하고, 화면 좌측 상단에 원을 그림
3. 원을 오른쪽으로 이동시키는 애니메이션을 만들기 위해 변수 사용이 필요함.
4. 변수는 고정된 숫자를 대신하여 변화하는 값을 나타냄.
5. 변수 이름은 사용자가 선택하되, 해당 값이 마우스의 x좌표와 같이 변화하도록 설정할 수 있음

---

## 변수와 정수값 컴퓨터 메모리에서 저장하는 방법

1. x 포지션 변수를 생성하여 정수를 저장함. 이 변수는 화면의 x좌표를 나타냄
2. 프로그램에서 x 포지션 변수를 사용하여 값을 변경하거나 활용함
3. 변수를 선언할 때 int 키워드를 사용하여 해당 변수가 정수를 저장한다는 것을 명시함
4. 변수를 처음에는 0으로 초기화하고, 프로그램 실행 중에 필요에 따라 값을 변경할 수 있음.
5. 변수를 사용하여 화면의 픽셀 위치를 제어하고, 위치를 변경함으로써 애니메이션 효과를 만들 수 있음.

---

## 프로세싱 변수: int부터 float까지

프로그램 실행 시 가장 먼저 코드가 실행되며, setup이 실행된 후 draw가 반복됨. 

프로그램은 종료될 때까지 x 포지션 변수를 기억하며 중간에 값을 변경할 수 있음. 

변수를 선언할 때 int 키워드를 사용하여 정수를 저장함. 

변수를 사용하여 화면의 픽셀 위치를 제어하고, 위치를 변경하여 애니메이션 효과를 만듦. 

변수의 종류는 프로세싱 레퍼런스 페이지에서 확인할 수 있으며, int 변수는 정수를, float 변수는 소수를 저장함. 

이를 통해 변수를 올바르게 사용하여 프로그래밍을 수월하게 할 수 있음.

---

## **프로그래밍 변수 이름 설정 규칙과 시스템 변수 활용**

초반에는 플로트 변수를 많이 활용할 것임. 

불리언 변수는 컴퓨터에서 가장 기본적이며, 참과 거짓을 저장함. 

자바이트 변수는 -128부터 127까지의 값을 저장할 수 있고, 캐릭터 변수는 문자 하나를 저장할 수 있음. 

더블 변수는 플로트와 유사하지만 큰 의미가 없어 넘어가고, 롱 변수는 더 넓은 범위의 정수를 저장할 수 있음. 

주로 플로트 변수를 사용하여 코딩을 시작할 것임.

---

## 마우스를 따라 색상 변화 만들기

코드를 통해 마우스를 따라 다니면서 시간이 지남에 따라 색상이 변하도록 만들었음. 프레임 카운트 시스템 변수를 활용하여 색상을 조절함. 프레임 카운트는 프로그램이 실행될 때마다 1씩 증가함. 이를 이용하여 색상값을 변화시켰고, 4의 배수마다 빨간색에서 시작하여 빨, 주, 노, 초, 파, 남, 보, 백, 상 순으로 색이 변화함. 이후 다시 처음 색상으로 돌아오며, 이러한 변화를 반복함. 이를 위해 프레임 카운트를 256으로 나눈 나머지를 활용하여 0부터 255까지의 범위를 반복하도록 함. 결과적으로 색상이 변하면서 밝기가 깜빡거리는 효과를 얻을 수 있.

---

## 화면 중간 이동 후, 랜덤 밝기 색 지정하기

- 화면 중앙에 요소를 배치할 때는 시스템 변수를 활용하여 윈도우 크기에 관계없이 자동으로 중앙에 위치하도록 코드를 작성함.
- 색상을 지정할 때는 색상 채도와 명도를 활용하며, 명도 값을 랜덤으로 변경하여 다양한 효과를 표현할 수 있음.
- 랜덤 함수를 사용할 때는 0부터 255 사이의 값을 생성하여 밝기 값을 조절함.
- 이를 통해 요소가 화면을 따라 이동하면서 색상과 밝기가 랜덤하게 변하는 효과를 구현할 수 있음.
- 랜덤 함수는 다양한 상황에서 유용하게 활용될 수 있음.

---

## **프로세싱에서 조건문을 활용한 마우스 위치에 따른 색상 변경**

### **프로세싱에서 조건문 사용하기**

- **조건문 소개**
    - 조건문은 특정한 상황에서만 실행되는 코드를 작성할 때 사용됩니다.
    - 조건문은 불리언(boolean) 변수와 밀접한 연관이 있습니다.
    - 프로세싱에서 참은 **`true`**, 거짓은 **`false`**로 표현됩니다.
- **기본 문법**
    - **`if (조건) { 실행 코드 }`**: 조건이 참일 경우에만 실행됩니다.
    - **`else { 실행 코드 }`**: 조건이 거짓일 경우 실행됩니다.
- **첫 번째 예시: 마우스 위치에 따라 배경 색 변경**
    - **`if (마우스 x > 250) { 배경 색 = 흰색; }`**: 마우스 x 위치가 250보다 큰 경우 배경 색을 흰색으로 변경합니다.
    - **`else { 배경 색 = 검정색; }`**: 그 외의 경우에는 배경 색을 검정색으로 변경합니다.
- **두 번째 예시: 마우스 위치에 따라 다양한 색 적용**
    - 조건을 더 세분화하여 마우스 위치에 따라 검정, 회색, 파랑 색을 적용합니다.
    - **`if (마우스 x < 전체 너비의 3분의 1) { 배경 색 = 검정색; }`**
    - **`else if (마우스 x < 전체 너비의 3분의 2) { 배경 색 = 회색; }`**
    - **`else { 배경 색 = 파랑; }`**: 마우스 위치에 따라 다양한 색이 적용됩니다.
- **코드 작성 시 주의할 점**
    - **`if`**문 안의 코드가 참이 아닌 경우에는 해당 코드가 실행되지 않습니다.
    - 즉, **`if`**문 안의 조건이 참일 때만 실행되는 코드를 작성해야 합니다.

---

## **프로세싱에서 조건문을 활용한 구조화된 코드 작성하기**

### **프로세싱에서 조건문을 사용한 코드 정리**

- **중요한 부분 강조**
    - 코드 정렬을 통해 코드의 구조를 명확히 확인할 수 있습니다.
    - 코드의 일관된 들여쓰기는 가독성을 향상시킵니다.
    - 주석을 추가하여 코드의 각 부분이 어떤 역할을 하는지 설명해야 합니다.
- **조건문의 올바른 사용**
    - **`if-else`** 구문을 사용하여 마우스 위치에 따라 배경 색을 변경하는 예시를 보여줍니다.
    - 적절한 들여쓰기와 주석을 통해 코드를 명확하게 설명합니다.
- **코드 구조화**
    - 코드를 여러 단계로 분할하여 가독성을 높입니다.
    - 예시로는 마우스 위치에 따라 다섯 단계의 색상을 적용하는 코드를 제시합니다.
- **추가적인 팁**
    - 코드를 읽고 수정할 때는 항상 코드 정렬을 사용하세요.
    - 들여쓰기와 주석을 통해 코드의 의도를 명확히 전달하세요.
    - 여러 개의 조건문을 사용하여 복잡한 작업을 수행할 수 있습니다.

---

## **프로세싱에서 조건문을 활용한 코드의 가독성과 구조화**

### **프로세싱에서 조건문을 사용한 코드 정리**

- **구조화된 코드**
    - 코드를 구조화하여 가독성을 높입니다.
    - 정렬된 코드와 일관된 들여쓰기를 사용합니다.
- **주석을 활용한 설명**
    - 각 코드 블록에 주석을 추가하여 코드의 의도를 명확히 전달합니다.
    - 코드의 각 부분이 어떤 역할을 하는지 설명합니다.
- **조건문의 활용**
    - 마우스 위치에 따라 배경 색을 변경하는 조건문을 예시로 제시합니다.
    - 조건문을 사용하여 다양한 상황에 대응합니다.
- **코드의 분할**
    - 코드를 여러 단계로 나누어 복잡성을 줄입니다.
    - 다섯 단계의 색상을 적용하는 예시를 통해 코드를 설명합니다.
- **유용한 팁**
    - 코드를 수정할 때는 항상 코드 정렬을 사용하세요.
    - 코드의 가독성을 높이기 위해 들여쓰기와 주석을 적절히 활용하세요.

---

## **프로세싱에서 조건문과 비교 연산자의 활용**

### **프로세싱에서의 조건문 활용과 비교 연산자**

- **조건문의 다양한 활용**
    - **`if-else`** 구문을 사용하여 다양한 상황에 대응
    - 마우스 위치에 따라 배경 색을 변경하는 예시를 제시함
- **비교 연산자의 활용**
    - 프로세싱 레퍼런스 페이지에서 제공되는 비교 연산자를 설명함.
    - **`==`**, **`!=`**, **`<`**, **`<=`**, **`>`**, **`>=`** 연산자를 사용하여 값들을 비교함
- **비교 연산자의 종류**
    - 두 값이 같은지, 다른지, 작은지, 작거나 같은지, 큰지, 크거나 같은지를 확인함
    - 이러한 연산자를 활용하여 조건문을 구성함
- **논리 연산자의 활용**
    - **`&&`**와 **`||`**를 사용하여 여러 조건을 결합할 수 있음.
    - 조건문을 보다 복잡하게 구성할 수 있음.
- **코드 작성 예시**
    - 마우스 위치에 따라 화면을 네 영역으로 나누고, 각 영역에 따라 다른 배경 색상을 적용하는 코드를 작성함
- **추가적인 팁**
    - 프로세싱 레퍼런스 페이지를 참고하여 다양한 연산자를 활용하기.
    - 코드를 작성할 때 들여쓰기와 주석을 활용하여 가독성을 높이기.
    
    ---
    
    ## **프로세싱을 사용한 원의 화면 내 이동 제어하기**
    
    ### **화면 밖으로 나가지 않고 왔다갔다하는 원 만들기**
    
    - **목표**
        - 원이 화면의 양쪽 벽에 부딪치면서 왔다갔다하도록 만듦.
        - 원의 이동 방향을 바꾸는 조건을 설정하여 구현함
    - **변수 설정**
        - **`스피드`** 변수를 만들어 원의 이동 속도를 조절함
    - **원의 이동 제어**
        - **`x`** 포지션에 **`스피드`**를 더하여 원을 오른쪽으로 이동함
        - 화면을 벗어나면 **`스피드`** 값을 음수로 변경하여 반대 방향으로 이동하도록 함
        - 왼쪽 벽에 부딪치면 다시 양수로 변경하여 오른쪽으로 이동함.
    - **코드 작성 예시**
        - **`if`** 구문을 사용하여 화면 밖으로 나가는 경우와 왼쪽 벽에 부딪치는 경우를 처리함.
        - 원의 이동 방향을 반대로 바꾸는 방법을 설명함.
    
    ---
    
    ## **프로세싱을 사용한 반복문의 이해와 활용**
    
    ### **프로세싱에서의 반복문 활용**
    
    - **반복문의 중요성**
        - 컴퓨터 프로그래밍에서 반복문은 가장 중요한 요소 중 하나임.
        - 반복적인 작업을 효율적으로 처리할 수 있도록 해줌
    - **반복문의 활용**
        - 프로세싱을 사용하여 비주얼 작업을 할 때 반복문은 매우 유용함.
        - 많은 파티클을 생성하거나 특정 패턴을 만드는 작업에서 반복문이 사용됨.
    - **반복문의 종류**
        - **`while`** 루프는 조건을 만족할 때까지 코드를 반복 실행함
        - 이때 조건이 항상 참이면 무한 루프에 빠질 수 있으므로 주의해야 함
    - **주의할 점**
        - 무한 루프에 빠지는 것을 피하기 위해 조건을 제대로 설정해야 함.
        - 조건이 항상 참이 되는 경우를 피하여 코드가 영원히 실행되는 상황을 방지해야 함.
    
    ---
    
    ## **반복문을 사용하여 점 찍기**
    
    ```java
    javaCopy code
    void setup() {
      size(500, 500);
      background(255);
      strokeWeight(10);
      // p(250, 20); // 처음에 점 하나 찍기
      // p(270, 20); // 20픽셀 간격으로 점 찍기
      // p(290, 20);
      // ... 이런식으로 수작업으로 점을 찍을 수 있지만 번거롭습니다.
    
      int x = 250; // 초기 x 좌표
      int y = 20;  // 고정된 y 좌표
      int gap = 20; // 점 사이의 간격
    
      while (x <= 490) { // x 좌표가 490을 넘지 않을 때까지 반복
        p(x, y); // 점 찍기
        x += gap; // x 좌표를 간격만큼 증가
      }
    }
    
    void p(int x, int y) {
      point(x, y); // 점 찍기
    }
    
    ```
    
    ### **반복문을 사용한 점 찍기 설명**
    
    - **`setup()`** 함수:
        - 화면 크기를 500x500으로 설정함.
        - 배경을 흰색(255)으로 설정함.
        - 선의 굵기를 10으로 설정함
        - 주석 처리된 부분은 수작업으로 점을 찍는 코드임.
    - **`p()`** 함수:
        - 주어진 좌표에 점을 찍는 함수임
    - **`while`** 루프:
        - **`x`** 좌표가 490을 넘지 않을 때까지 반복하여 점을 찍음.
        - 각 반복에서 **`x`** 좌표를 20만큼 증가시켜서 20픽셀 간격으로 점을 찍기.
    
    ### **반복문을 사용한 점 찍기 결과**
    
    - 이 코드를 실행하면, x 좌표가 20픽셀 간격으로 증가하면서 오른쪽으로 이동하는 점이 찍힘.

---

## **변수를 사용한 반복문**

```java
javaCopy code
void setup() {
  size(500, 500);
  background(255);
  strokeWeight(10);

  float x = 20; // x 좌표 변수 초기화

  while (x < 500) { // x 좌표가 500 미만인 동안 반복
    p(x, 20); // 점 찍기
    x += 20; // x 좌표를 20만큼 증가
  }
}

void p(float x, float y) {
  point(x, y); // 점 찍기
}

```

### **변수를 사용한 반복문 설명**

- **`setup()`** 함수:
    - 화면 크기를 500x500으로 설정함.
    - 배경을 흰색(255)으로 설정함.
    - 선의 굵기를 10으로 설정함.
- 변수 **`x`**:
    - **`float`** 형식으로 선언되었음.
    - 초기값은 20으로 설정되어 있음.
    - 이 변수를 사용하여 점의 x 좌표를 계속 변경함.
- **`while`** 반복문:
    - **`x`** 좌표가 500 미만일 때까지 반복됨
    - 각 반복에서 **`x`** 좌표를 20씩 증가시켜 20픽셀 간격으로 점을 찍음.
- **`p()`** 함수:
    - 주어진 좌표에 점을 찍는 함수임

### **변수를 사용한 반복문 결과**

- 이 코드를 실행하면, x 좌표가 20부터 시작하여 20씩 증가하면서 오른쪽으로 이동하는 점이 찍힘.
- 간격을 10으로 변경하면 간격이 좁아지는 것을 확인할 수 있음.

### **`for` 반복문**

**`for`** 반복문은 초기화, 조건식, 증감식이 한 줄에 모두 포함되어 있는 구문으로, 반복 횟수를 명확하게 지정할 때 주로 사용됨. 

이전에 사용한 **`while`** 반복문과 유사한 역할을 수행하지만, 조건식과 증감식이 한 곳에 모여 있어 코드를 간결하게 작성할 수 있음. 이를 통해 코드의 가독성을 높일 수 있음.

---

## **`for` 반복문을 사용한 점 찍기**

```java
javaCopy code
void setup() {
  size(500, 500);
  background(255);
  strokeWeight(10);

  for (float x = 20; x < 500; x += 20) { // x 좌표가 500 미만인 동안 반복
    point(x, 20); // 점 찍기
  }
}

```

### **`for` 반복문 설명**

- **`setup()`** 함수:
    - 화면 크기를 500x500으로 설정함
    - 배경을 흰색(255)으로 설정함.
    - 선의 굵기를 10으로 설정함
- **`for`** 반복문:
    - **`x`** 변수를 선언하고 초기값을 20으로 설정함
    - **`x`** 좌표가 500 미만일 때까지 반복됨
    - 각 반복에서 **`x`** 좌표를 20씩 증가시켜 20픽셀 간격으로 점을 찍음

### **`for` 반복문 결과**

- **`for`** 반복문을 사용하여 간결하고 가독성이 좋은 코드로 점을 찍었음
- 코드의 의도가 명확하게 드러나며, 반복 횟수를 명시적으로 지정했음.

### **반복문의 활용**

- **`for`** 반복문은 초기값, 조건식, 증감식이 한 줄에 모두 포함되어 있어서 코드를 간결하게 작성할 수 있음
- 초당 60회 반복되는 **`draw()`** 함수를 사용하여도 점을 찍을 수 있지만, **`for`** 반복문을 사용하는 것이 코드를 더 간결하게 만듦.
